### ocaml.lib.mk -- Building OCaml libraries

# Author: Michael Grünewald
# Date: Tue Apr  5 12:31:04 CEST 2005

# BSD Owl Scripts (https://github.com/michipili/bsdowl)
# This file is part of BSD Owl Scripts
#
# Copyright © 2002–2017 Michael Grünewald. All Rights Reserved.
#
# This file must be used under the terms of the BSD license.
# This source file is licensed as described in the file LICENSE, which
# you should have received as part of this distribution.


### SYNOPSIS

# LIBRARY=	newton
# SRCS+=	newton.ml
#
# .include "ocaml.lib.mk"


### DESCRIPTION

# Build an ocaml library, compiling each of the module listed in SRCS
# and creating a library named as LIBRARY.
#
# It supports building bytecode and native libraries, ocamlfind,
# lexers and parsers generated by ocamllex and ocamlyacc and
# debugging, profiling as well.

# Variables:
#
#
#  LIBRARY
#   The name of the library
#
#
#  SRCS
#   Files to put in the library
#
#   It can list implementation files, lexer and parser definitions.
#
#
#  LIBOWN, LIBGRP, LIBMODE, LIBNAME
#   Paramters of the library installation
#
#   See `bps.own.mk` for a closer description of these variables.
#
#
#  LIBDIR [${ocamllibdir}${PACKAGEDIR}]
#   The installation target for libraries
#
#   The value defined in `bps.own.mk` is suited for C libraries but not
#   for OCaml objects that are rather installed in the same location as
#   the standard library.
#
#
#  ocamllibdir [${libdir}]
#   Directory for ocaml libraries
#
#   See "USES+=site-lib" below.
#
#
# Uses:
#
#  site-lib: No argument allowed
#   Use ${libdir}/ocaml/site-lib as default value for ocamllibdir
#
#
#  dynlink: No argument allowed
#   Prepare dynlink plugins


### IMPLEMENTATION

THISMODULE=		ocaml.lib

.if !defined(LIBRARY)||empty(LIBRARY)
.error The ocaml.lib.mk expects you to set the LIBRARY variable to a sensible value.
.endif

PRODUCT=		${LIBRARY}
_PACKAGE_CANDIDATE=	${LIBRARY}

.include "ocaml.init.mk"

_OCAML_LIB:=		${LIBRARY}

.for lib in ${_OCAML_LIB}
SRCS.${lib:T}?=		${SRCS}
.if defined(_OCAML_COMPILE_NATIVE)
SRCS.${lib:T}.cmxa?=	${SRCS.${lib:T}}
_OCAML_SRCS+=		SRCS.${lib}.cmxa
_OCAML_CMXA+=		${lib:T}.cmxa
_OCAML_A+=		${lib:T}.a
_OCAML_SRCS.${lib:T}.cmxa+=\
			${SRCS.${lib}.cmxa:C@\.ml[ly]@.ml@:M*.ml:.ml=.cmx}
LIB+=			${lib:T}.cmxa ${lib:T}.a
.endif
.if defined(_OCAML_COMPILE_NATIVE)&&defined(_OCAML_COMPILE_PLUGIN)
_OCAML_CMXS+=		${lib:T}.cmxs
LIB+=			${lib:T}.cmxs
CLEANFILES+=		${lib:T}.cmxs
_OCAML_SRCS.${lib:T}.cmxs+=\
			${_OCAML_SRCS.${lib:T}.cmxa}
.endif
.if defined(_OCAML_COMPILE_BYTE)
SRCS.${lib:T}.cma?=	${SRCS.${lib:T}}
_OCAML_SRCS+=		SRCS.${lib:T}.cma
_OCAML_CMA+=		${lib:T}.cma
_OCAML_SRCS.${lib:T}.cma+=\
			${SRCS.${lib:T}.cma:C@\.ml[ly]@.ml@:M*.ml:.ml=.cmo}
LIB+=			${lib}.cma
.endif
.if!empty(SRCS.${lib:T}:C@\.ml[ly]@.ml@:M*.ml)
LIB+=			${SRCS.${lib:T}:C@\.ml[ly]@.ml@:M*.ml:.ml=.cmi}
.endif
.endfor

.include "ocaml.main.mk"

.for lib in ${_OCAML_LIB}
.if defined(_OCAML_COMPILE_NATIVE)
${lib:T}.cmxa: ${_OCAML_SRCS.${lib:T}.cmxa}
.endif
.if defined(_OCAML_COMPILE_BYTE)
${lib:T}.cma: ${_OCAML_SRCS.${lib:T}.cma}
.endif
.if defined(_OCAML_COMPILE_NATIVE)&&defined(_OCAML_COMPILE_PLUGIN)
${lib:T}.cmxs: ${_OCAML_SRCS.${lib:T}.cmxs}
.endif
.endfor


.if exists(META)||exists(META.in)||defined(META)
.include "ocaml.meta.mk"
.endif

.include "bps.clean.mk"
.include "bps.files.mk"
.include "bps.usertarget.mk"

.if !target(display-ocaml-lib)
display-ocaml-lib:
	${INFO} 'Display ocaml.lib information'
.for displayvar in LIBRARY
	${MESG} "${displayvar}=${${displayvar}}"
.endfor
.for lib in ${LIBRARY}
.for suffix in cma cmxa cmxs
.for displayvar in _OCAML_SRCS.${lib:T}.${suffix}
	${MESG} "${displayvar}=${${displayvar}}"
.endfor
.endfor
.endfor
.endif

### End of file `ocaml.lib.mk'
